// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proto/message.proto

#ifndef PROTOBUF_proto_2fmessage_2eproto__INCLUDED
#define PROTOBUF_proto_2fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
namespace lrobot {
namespace lidarvolumemeas {
class MeasResult;
class MeasResultDefaultTypeInternal;
extern MeasResultDefaultTypeInternal _MeasResult_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Model;
class ModelDefaultTypeInternal;
extern ModelDefaultTypeInternal _Model_default_instance_;
class Point;
class PointDefaultTypeInternal;
extern PointDefaultTypeInternal _Point_default_instance_;
class Scan;
class ScanDefaultTypeInternal;
extern ScanDefaultTypeInternal _Scan_default_instance_;
class Statistic;
class StatisticDefaultTypeInternal;
extern StatisticDefaultTypeInternal _Statistic_default_instance_;
class SysInfo;
class SysInfoDefaultTypeInternal;
extern SysInfoDefaultTypeInternal _SysInfo_default_instance_;
class Triangle;
class TriangleDefaultTypeInternal;
extern TriangleDefaultTypeInternal _Triangle_default_instance_;
}  // namespace lidarvolumemeas
}  // namespace lrobot

namespace lrobot {
namespace lidarvolumemeas {

namespace protobuf_proto_2fmessage_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_proto_2fmessage_2eproto

enum State {
  Idle = 1,
  Measuring = 2,
  MeasureFinished = 3
};
bool State_IsValid(int value);
const State State_MIN = Idle;
const State State_MAX = MeasureFinished;
const int State_ARRAYSIZE = State_MAX + 1;

const ::google::protobuf::EnumDescriptor* State_descriptor();
inline const ::std::string& State_Name(State value) {
  return ::google::protobuf::internal::NameOfEnum(
    State_descriptor(), value);
}
inline bool State_Parse(
    const ::std::string& name, State* value) {
  return ::google::protobuf::internal::ParseNamedEnum<State>(
    State_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.Point) */ {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Point(Point&& from) noexcept
    : Point() {
    *this = ::std::move(from);
  }

  inline Point& operator=(Point&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  static inline const Point* internal_default_instance() {
    return reinterpret_cast<const Point*>(
               &_Point_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(Point* other);
  friend void swap(Point& a, Point& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Point* New() const PROTOBUF_FINAL { return New(NULL); }

  Point* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Point* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // required float y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // required float z = 3;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 3;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.Point)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_z();
  void clear_has_z();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Triangle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.Triangle) */ {
 public:
  Triangle();
  virtual ~Triangle();

  Triangle(const Triangle& from);

  inline Triangle& operator=(const Triangle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Triangle(Triangle&& from) noexcept
    : Triangle() {
    *this = ::std::move(from);
  }

  inline Triangle& operator=(Triangle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Triangle& default_instance();

  static inline const Triangle* internal_default_instance() {
    return reinterpret_cast<const Triangle*>(
               &_Triangle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(Triangle* other);
  friend void swap(Triangle& a, Triangle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Triangle* New() const PROTOBUF_FINAL { return New(NULL); }

  Triangle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Triangle& from);
  void MergeFrom(const Triangle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Triangle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 v0 = 1;
  bool has_v0() const;
  void clear_v0();
  static const int kV0FieldNumber = 1;
  ::google::protobuf::int32 v0() const;
  void set_v0(::google::protobuf::int32 value);

  // required int32 v1 = 2;
  bool has_v1() const;
  void clear_v1();
  static const int kV1FieldNumber = 2;
  ::google::protobuf::int32 v1() const;
  void set_v1(::google::protobuf::int32 value);

  // required int32 v2 = 3;
  bool has_v2() const;
  void clear_v2();
  static const int kV2FieldNumber = 3;
  ::google::protobuf::int32 v2() const;
  void set_v2(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.Triangle)
 private:
  void set_has_v0();
  void clear_has_v0();
  void set_has_v1();
  void clear_has_v1();
  void set_has_v2();
  void clear_has_v2();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 v0_;
  ::google::protobuf::int32 v1_;
  ::google::protobuf::int32 v2_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.Model) */ {
 public:
  Model();
  virtual ~Model();

  Model(const Model& from);

  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Model(Model&& from) noexcept
    : Model() {
    *this = ::std::move(from);
  }

  inline Model& operator=(Model&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();

  static inline const Model* internal_default_instance() {
    return reinterpret_cast<const Model*>(
               &_Model_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Model* other);
  friend void swap(Model& a, Model& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Model* New() const PROTOBUF_FINAL { return New(NULL); }

  Model* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Model* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lrobot.lidarvolumemeas.Point points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::lrobot::lidarvolumemeas::Point& points(int index) const;
  ::lrobot::lidarvolumemeas::Point* mutable_points(int index);
  ::lrobot::lidarvolumemeas::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >&
      points() const;

  // repeated .lrobot.lidarvolumemeas.Triangle triangles = 2;
  int triangles_size() const;
  void clear_triangles();
  static const int kTrianglesFieldNumber = 2;
  const ::lrobot::lidarvolumemeas::Triangle& triangles(int index) const;
  ::lrobot::lidarvolumemeas::Triangle* mutable_triangles(int index);
  ::lrobot::lidarvolumemeas::Triangle* add_triangles();
  ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Triangle >*
      mutable_triangles();
  const ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Triangle >&
      triangles() const;

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.Model)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point > points_;
  ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Triangle > triangles_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Statistic : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.Statistic) */ {
 public:
  Statistic();
  virtual ~Statistic();

  Statistic(const Statistic& from);

  inline Statistic& operator=(const Statistic& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Statistic(Statistic&& from) noexcept
    : Statistic() {
    *this = ::std::move(from);
  }

  inline Statistic& operator=(Statistic&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Statistic& default_instance();

  static inline const Statistic* internal_default_instance() {
    return reinterpret_cast<const Statistic*>(
               &_Statistic_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Statistic* other);
  friend void swap(Statistic& a, Statistic& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Statistic* New() const PROTOBUF_FINAL { return New(NULL); }

  Statistic* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Statistic& from);
  void MergeFrom(const Statistic& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Statistic* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double length = 1;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 1;
  double length() const;
  void set_length(double value);

  // required double width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  double width() const;
  void set_width(double value);

  // required double height = 3;
  bool has_height() const;
  void clear_height();
  static const int kHeightFieldNumber = 3;
  double height() const;
  void set_height(double value);

  // required double volume = 4;
  bool has_volume() const;
  void clear_volume();
  static const int kVolumeFieldNumber = 4;
  double volume() const;
  void set_volume(double value);

  // required double velocity = 5;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 5;
  double velocity() const;
  void set_velocity(double value);

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.Statistic)
 private:
  void set_has_length();
  void clear_has_length();
  void set_has_width();
  void clear_has_width();
  void set_has_height();
  void clear_has_height();
  void set_has_volume();
  void clear_has_volume();
  void set_has_velocity();
  void clear_has_velocity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double length_;
  double width_;
  double height_;
  double volume_;
  double velocity_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SysInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.SysInfo) */ {
 public:
  SysInfo();
  virtual ~SysInfo();

  SysInfo(const SysInfo& from);

  inline SysInfo& operator=(const SysInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SysInfo(SysInfo&& from) noexcept
    : SysInfo() {
    *this = ::std::move(from);
  }

  inline SysInfo& operator=(SysInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysInfo& default_instance();

  static inline const SysInfo* internal_default_instance() {
    return reinterpret_cast<const SysInfo*>(
               &_SysInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(SysInfo* other);
  friend void swap(SysInfo& a, SysInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SysInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  SysInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SysInfo& from);
  void MergeFrom(const SysInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SysInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double temperature = 2;
  bool has_temperature() const;
  void clear_temperature();
  static const int kTemperatureFieldNumber = 2;
  double temperature() const;
  void set_temperature(double value);

  // required .lrobot.lidarvolumemeas.State state = 1;
  bool has_state() const;
  void clear_state();
  static const int kStateFieldNumber = 1;
  ::lrobot::lidarvolumemeas::State state() const;
  void set_state(::lrobot::lidarvolumemeas::State value);

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.SysInfo)
 private:
  void set_has_state();
  void clear_has_state();
  void set_has_temperature();
  void clear_has_temperature();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  double temperature_;
  int state_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Scan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.Scan) */ {
 public:
  Scan();
  virtual ~Scan();

  Scan(const Scan& from);

  inline Scan& operator=(const Scan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Scan(Scan&& from) noexcept
    : Scan() {
    *this = ::std::move(from);
  }

  inline Scan& operator=(Scan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Scan& default_instance();

  static inline const Scan* internal_default_instance() {
    return reinterpret_cast<const Scan*>(
               &_Scan_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Scan* other);
  friend void swap(Scan& a, Scan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Scan* New() const PROTOBUF_FINAL { return New(NULL); }

  Scan* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Scan& from);
  void MergeFrom(const Scan& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Scan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .lrobot.lidarvolumemeas.Point points = 2;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 2;
  const ::lrobot::lidarvolumemeas::Point& points(int index) const;
  ::lrobot::lidarvolumemeas::Point* mutable_points(int index);
  ::lrobot::lidarvolumemeas::Point* add_points();
  ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >&
      points() const;

  // required .lrobot.lidarvolumemeas.Statistic statistic = 1;
  bool has_statistic() const;
  void clear_statistic();
  static const int kStatisticFieldNumber = 1;
  const ::lrobot::lidarvolumemeas::Statistic& statistic() const;
  ::lrobot::lidarvolumemeas::Statistic* mutable_statistic();
  ::lrobot::lidarvolumemeas::Statistic* release_statistic();
  void set_allocated_statistic(::lrobot::lidarvolumemeas::Statistic* statistic);

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.Scan)
 private:
  void set_has_statistic();
  void clear_has_statistic();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point > points_;
  ::lrobot::lidarvolumemeas::Statistic* statistic_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeasResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.MeasResult) */ {
 public:
  MeasResult();
  virtual ~MeasResult();

  MeasResult(const MeasResult& from);

  inline MeasResult& operator=(const MeasResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeasResult(MeasResult&& from) noexcept
    : MeasResult() {
    *this = ::std::move(from);
  }

  inline MeasResult& operator=(MeasResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MeasResult& default_instance();

  static inline const MeasResult* internal_default_instance() {
    return reinterpret_cast<const MeasResult*>(
               &_MeasResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(MeasResult* other);
  friend void swap(MeasResult& a, MeasResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeasResult* New() const PROTOBUF_FINAL { return New(NULL); }

  MeasResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MeasResult& from);
  void MergeFrom(const MeasResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MeasResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .lrobot.lidarvolumemeas.Statistic statistic = 1;
  bool has_statistic() const;
  void clear_statistic();
  static const int kStatisticFieldNumber = 1;
  const ::lrobot::lidarvolumemeas::Statistic& statistic() const;
  ::lrobot::lidarvolumemeas::Statistic* mutable_statistic();
  ::lrobot::lidarvolumemeas::Statistic* release_statistic();
  void set_allocated_statistic(::lrobot::lidarvolumemeas::Statistic* statistic);

  // required .lrobot.lidarvolumemeas.Model model = 2;
  bool has_model() const;
  void clear_model();
  static const int kModelFieldNumber = 2;
  const ::lrobot::lidarvolumemeas::Model& model() const;
  ::lrobot::lidarvolumemeas::Model* mutable_model();
  ::lrobot::lidarvolumemeas::Model* release_model();
  void set_allocated_model(::lrobot::lidarvolumemeas::Model* model);

  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.MeasResult)
 private:
  void set_has_statistic();
  void clear_has_statistic();
  void set_has_model();
  void clear_has_model();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::lrobot::lidarvolumemeas::Statistic* statistic_;
  ::lrobot::lidarvolumemeas::Model* model_;
  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:lrobot.lidarvolumemeas.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum DataCase {
    kInfo = 1,
    kScan = 2,
    kResult = 3,
    DATA_NOT_SET = 0,
  };

  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const PROTOBUF_FINAL { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .lrobot.lidarvolumemeas.SysInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::lrobot::lidarvolumemeas::SysInfo& info() const;
  ::lrobot::lidarvolumemeas::SysInfo* mutable_info();
  ::lrobot::lidarvolumemeas::SysInfo* release_info();
  void set_allocated_info(::lrobot::lidarvolumemeas::SysInfo* info);

  // optional .lrobot.lidarvolumemeas.Scan scan = 2;
  bool has_scan() const;
  void clear_scan();
  static const int kScanFieldNumber = 2;
  const ::lrobot::lidarvolumemeas::Scan& scan() const;
  ::lrobot::lidarvolumemeas::Scan* mutable_scan();
  ::lrobot::lidarvolumemeas::Scan* release_scan();
  void set_allocated_scan(::lrobot::lidarvolumemeas::Scan* scan);

  // optional .lrobot.lidarvolumemeas.MeasResult result = 3;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 3;
  const ::lrobot::lidarvolumemeas::MeasResult& result() const;
  ::lrobot::lidarvolumemeas::MeasResult* mutable_result();
  ::lrobot::lidarvolumemeas::MeasResult* release_result();
  void set_allocated_result(::lrobot::lidarvolumemeas::MeasResult* result);

  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:lrobot.lidarvolumemeas.Message)
 private:
  void set_has_info();
  void set_has_scan();
  void set_has_result();

  inline bool has_data() const;
  void clear_data();
  inline void clear_has_data();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  union DataUnion {
    DataUnion() {}
    ::lrobot::lidarvolumemeas::SysInfo* info_;
    ::lrobot::lidarvolumemeas::Scan* scan_;
    ::lrobot::lidarvolumemeas::MeasResult* result_;
  } data_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_proto_2fmessage_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Point

// required float x = 1;
inline bool Point::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Point::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Point::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Point::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Point::x() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Point.x)
  return x_;
}
inline void Point::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Point.x)
}

// required float y = 2;
inline bool Point::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Point::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Point::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Point::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Point::y() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Point.y)
  return y_;
}
inline void Point::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Point.y)
}

// required float z = 3;
inline bool Point::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Point::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Point::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Point::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Point::z() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Point.z)
  return z_;
}
inline void Point::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Point.z)
}

// -------------------------------------------------------------------

// Triangle

// required int32 v0 = 1;
inline bool Triangle::has_v0() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Triangle::set_has_v0() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Triangle::clear_has_v0() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Triangle::clear_v0() {
  v0_ = 0;
  clear_has_v0();
}
inline ::google::protobuf::int32 Triangle::v0() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Triangle.v0)
  return v0_;
}
inline void Triangle::set_v0(::google::protobuf::int32 value) {
  set_has_v0();
  v0_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Triangle.v0)
}

// required int32 v1 = 2;
inline bool Triangle::has_v1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Triangle::set_has_v1() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Triangle::clear_has_v1() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Triangle::clear_v1() {
  v1_ = 0;
  clear_has_v1();
}
inline ::google::protobuf::int32 Triangle::v1() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Triangle.v1)
  return v1_;
}
inline void Triangle::set_v1(::google::protobuf::int32 value) {
  set_has_v1();
  v1_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Triangle.v1)
}

// required int32 v2 = 3;
inline bool Triangle::has_v2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Triangle::set_has_v2() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Triangle::clear_has_v2() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Triangle::clear_v2() {
  v2_ = 0;
  clear_has_v2();
}
inline ::google::protobuf::int32 Triangle::v2() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Triangle.v2)
  return v2_;
}
inline void Triangle::set_v2(::google::protobuf::int32 value) {
  set_has_v2();
  v2_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Triangle.v2)
}

// -------------------------------------------------------------------

// Model

// repeated .lrobot.lidarvolumemeas.Point points = 1;
inline int Model::points_size() const {
  return points_.size();
}
inline void Model::clear_points() {
  points_.Clear();
}
inline const ::lrobot::lidarvolumemeas::Point& Model::points(int index) const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Model.points)
  return points_.Get(index);
}
inline ::lrobot::lidarvolumemeas::Point* Model::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Model.points)
  return points_.Mutable(index);
}
inline ::lrobot::lidarvolumemeas::Point* Model::add_points() {
  // @@protoc_insertion_point(field_add:lrobot.lidarvolumemeas.Model.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >*
Model::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:lrobot.lidarvolumemeas.Model.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >&
Model::points() const {
  // @@protoc_insertion_point(field_list:lrobot.lidarvolumemeas.Model.points)
  return points_;
}

// repeated .lrobot.lidarvolumemeas.Triangle triangles = 2;
inline int Model::triangles_size() const {
  return triangles_.size();
}
inline void Model::clear_triangles() {
  triangles_.Clear();
}
inline const ::lrobot::lidarvolumemeas::Triangle& Model::triangles(int index) const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Model.triangles)
  return triangles_.Get(index);
}
inline ::lrobot::lidarvolumemeas::Triangle* Model::mutable_triangles(int index) {
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Model.triangles)
  return triangles_.Mutable(index);
}
inline ::lrobot::lidarvolumemeas::Triangle* Model::add_triangles() {
  // @@protoc_insertion_point(field_add:lrobot.lidarvolumemeas.Model.triangles)
  return triangles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Triangle >*
Model::mutable_triangles() {
  // @@protoc_insertion_point(field_mutable_list:lrobot.lidarvolumemeas.Model.triangles)
  return &triangles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Triangle >&
Model::triangles() const {
  // @@protoc_insertion_point(field_list:lrobot.lidarvolumemeas.Model.triangles)
  return triangles_;
}

// -------------------------------------------------------------------

// Statistic

// required double length = 1;
inline bool Statistic::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Statistic::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Statistic::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Statistic::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline double Statistic::length() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Statistic.length)
  return length_;
}
inline void Statistic::set_length(double value) {
  set_has_length();
  length_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Statistic.length)
}

// required double width = 2;
inline bool Statistic::has_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Statistic::set_has_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Statistic::clear_has_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Statistic::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline double Statistic::width() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Statistic.width)
  return width_;
}
inline void Statistic::set_width(double value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Statistic.width)
}

// required double height = 3;
inline bool Statistic::has_height() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Statistic::set_has_height() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Statistic::clear_has_height() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Statistic::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline double Statistic::height() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Statistic.height)
  return height_;
}
inline void Statistic::set_height(double value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Statistic.height)
}

// required double volume = 4;
inline bool Statistic::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Statistic::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Statistic::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Statistic::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline double Statistic::volume() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Statistic.volume)
  return volume_;
}
inline void Statistic::set_volume(double value) {
  set_has_volume();
  volume_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Statistic.volume)
}

// required double velocity = 5;
inline bool Statistic::has_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Statistic::set_has_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Statistic::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Statistic::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double Statistic::velocity() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Statistic.velocity)
  return velocity_;
}
inline void Statistic::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.Statistic.velocity)
}

// -------------------------------------------------------------------

// SysInfo

// required .lrobot.lidarvolumemeas.State state = 1;
inline bool SysInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysInfo::clear_state() {
  state_ = 1;
  clear_has_state();
}
inline ::lrobot::lidarvolumemeas::State SysInfo::state() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.SysInfo.state)
  return static_cast< ::lrobot::lidarvolumemeas::State >(state_);
}
inline void SysInfo::set_state(::lrobot::lidarvolumemeas::State value) {
  assert(::lrobot::lidarvolumemeas::State_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.SysInfo.state)
}

// required double temperature = 2;
inline bool SysInfo::has_temperature() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysInfo::set_has_temperature() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysInfo::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysInfo::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline double SysInfo::temperature() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.SysInfo.temperature)
  return temperature_;
}
inline void SysInfo::set_temperature(double value) {
  set_has_temperature();
  temperature_ = value;
  // @@protoc_insertion_point(field_set:lrobot.lidarvolumemeas.SysInfo.temperature)
}

// -------------------------------------------------------------------

// Scan

// required .lrobot.lidarvolumemeas.Statistic statistic = 1;
inline bool Scan::has_statistic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Scan::set_has_statistic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Scan::clear_has_statistic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Scan::clear_statistic() {
  if (statistic_ != NULL) statistic_->::lrobot::lidarvolumemeas::Statistic::Clear();
  clear_has_statistic();
}
inline const ::lrobot::lidarvolumemeas::Statistic& Scan::statistic() const {
  const ::lrobot::lidarvolumemeas::Statistic* p = statistic_;
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Scan.statistic)
  return p != NULL ? *p : *reinterpret_cast<const ::lrobot::lidarvolumemeas::Statistic*>(
      &::lrobot::lidarvolumemeas::_Statistic_default_instance_);
}
inline ::lrobot::lidarvolumemeas::Statistic* Scan::mutable_statistic() {
  set_has_statistic();
  if (statistic_ == NULL) {
    statistic_ = new ::lrobot::lidarvolumemeas::Statistic;
  }
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Scan.statistic)
  return statistic_;
}
inline ::lrobot::lidarvolumemeas::Statistic* Scan::release_statistic() {
  // @@protoc_insertion_point(field_release:lrobot.lidarvolumemeas.Scan.statistic)
  clear_has_statistic();
  ::lrobot::lidarvolumemeas::Statistic* temp = statistic_;
  statistic_ = NULL;
  return temp;
}
inline void Scan::set_allocated_statistic(::lrobot::lidarvolumemeas::Statistic* statistic) {
  delete statistic_;
  statistic_ = statistic;
  if (statistic) {
    set_has_statistic();
  } else {
    clear_has_statistic();
  }
  // @@protoc_insertion_point(field_set_allocated:lrobot.lidarvolumemeas.Scan.statistic)
}

// repeated .lrobot.lidarvolumemeas.Point points = 2;
inline int Scan::points_size() const {
  return points_.size();
}
inline void Scan::clear_points() {
  points_.Clear();
}
inline const ::lrobot::lidarvolumemeas::Point& Scan::points(int index) const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Scan.points)
  return points_.Get(index);
}
inline ::lrobot::lidarvolumemeas::Point* Scan::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Scan.points)
  return points_.Mutable(index);
}
inline ::lrobot::lidarvolumemeas::Point* Scan::add_points() {
  // @@protoc_insertion_point(field_add:lrobot.lidarvolumemeas.Scan.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >*
Scan::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:lrobot.lidarvolumemeas.Scan.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::lrobot::lidarvolumemeas::Point >&
Scan::points() const {
  // @@protoc_insertion_point(field_list:lrobot.lidarvolumemeas.Scan.points)
  return points_;
}

// -------------------------------------------------------------------

// MeasResult

// required .lrobot.lidarvolumemeas.Statistic statistic = 1;
inline bool MeasResult::has_statistic() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MeasResult::set_has_statistic() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MeasResult::clear_has_statistic() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MeasResult::clear_statistic() {
  if (statistic_ != NULL) statistic_->::lrobot::lidarvolumemeas::Statistic::Clear();
  clear_has_statistic();
}
inline const ::lrobot::lidarvolumemeas::Statistic& MeasResult::statistic() const {
  const ::lrobot::lidarvolumemeas::Statistic* p = statistic_;
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.MeasResult.statistic)
  return p != NULL ? *p : *reinterpret_cast<const ::lrobot::lidarvolumemeas::Statistic*>(
      &::lrobot::lidarvolumemeas::_Statistic_default_instance_);
}
inline ::lrobot::lidarvolumemeas::Statistic* MeasResult::mutable_statistic() {
  set_has_statistic();
  if (statistic_ == NULL) {
    statistic_ = new ::lrobot::lidarvolumemeas::Statistic;
  }
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.MeasResult.statistic)
  return statistic_;
}
inline ::lrobot::lidarvolumemeas::Statistic* MeasResult::release_statistic() {
  // @@protoc_insertion_point(field_release:lrobot.lidarvolumemeas.MeasResult.statistic)
  clear_has_statistic();
  ::lrobot::lidarvolumemeas::Statistic* temp = statistic_;
  statistic_ = NULL;
  return temp;
}
inline void MeasResult::set_allocated_statistic(::lrobot::lidarvolumemeas::Statistic* statistic) {
  delete statistic_;
  statistic_ = statistic;
  if (statistic) {
    set_has_statistic();
  } else {
    clear_has_statistic();
  }
  // @@protoc_insertion_point(field_set_allocated:lrobot.lidarvolumemeas.MeasResult.statistic)
}

// required .lrobot.lidarvolumemeas.Model model = 2;
inline bool MeasResult::has_model() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MeasResult::set_has_model() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MeasResult::clear_has_model() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MeasResult::clear_model() {
  if (model_ != NULL) model_->::lrobot::lidarvolumemeas::Model::Clear();
  clear_has_model();
}
inline const ::lrobot::lidarvolumemeas::Model& MeasResult::model() const {
  const ::lrobot::lidarvolumemeas::Model* p = model_;
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.MeasResult.model)
  return p != NULL ? *p : *reinterpret_cast<const ::lrobot::lidarvolumemeas::Model*>(
      &::lrobot::lidarvolumemeas::_Model_default_instance_);
}
inline ::lrobot::lidarvolumemeas::Model* MeasResult::mutable_model() {
  set_has_model();
  if (model_ == NULL) {
    model_ = new ::lrobot::lidarvolumemeas::Model;
  }
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.MeasResult.model)
  return model_;
}
inline ::lrobot::lidarvolumemeas::Model* MeasResult::release_model() {
  // @@protoc_insertion_point(field_release:lrobot.lidarvolumemeas.MeasResult.model)
  clear_has_model();
  ::lrobot::lidarvolumemeas::Model* temp = model_;
  model_ = NULL;
  return temp;
}
inline void MeasResult::set_allocated_model(::lrobot::lidarvolumemeas::Model* model) {
  delete model_;
  model_ = model;
  if (model) {
    set_has_model();
  } else {
    clear_has_model();
  }
  // @@protoc_insertion_point(field_set_allocated:lrobot.lidarvolumemeas.MeasResult.model)
}

// -------------------------------------------------------------------

// Message

// optional .lrobot.lidarvolumemeas.SysInfo info = 1;
inline bool Message::has_info() const {
  return data_case() == kInfo;
}
inline void Message::set_has_info() {
  _oneof_case_[0] = kInfo;
}
inline void Message::clear_info() {
  if (has_info()) {
    delete data_.info_;
    clear_has_data();
  }
}
inline  const ::lrobot::lidarvolumemeas::SysInfo& Message::info() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Message.info)
  return has_info()
      ? *data_.info_
      : ::lrobot::lidarvolumemeas::SysInfo::default_instance();
}
inline ::lrobot::lidarvolumemeas::SysInfo* Message::mutable_info() {
  if (!has_info()) {
    clear_data();
    set_has_info();
    data_.info_ = new ::lrobot::lidarvolumemeas::SysInfo;
  }
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Message.info)
  return data_.info_;
}
inline ::lrobot::lidarvolumemeas::SysInfo* Message::release_info() {
  // @@protoc_insertion_point(field_release:lrobot.lidarvolumemeas.Message.info)
  if (has_info()) {
    clear_has_data();
    ::lrobot::lidarvolumemeas::SysInfo* temp = data_.info_;
    data_.info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_info(::lrobot::lidarvolumemeas::SysInfo* info) {
  clear_data();
  if (info) {
    set_has_info();
    data_.info_ = info;
  }
  // @@protoc_insertion_point(field_set_allocated:lrobot.lidarvolumemeas.Message.info)
}

// optional .lrobot.lidarvolumemeas.Scan scan = 2;
inline bool Message::has_scan() const {
  return data_case() == kScan;
}
inline void Message::set_has_scan() {
  _oneof_case_[0] = kScan;
}
inline void Message::clear_scan() {
  if (has_scan()) {
    delete data_.scan_;
    clear_has_data();
  }
}
inline  const ::lrobot::lidarvolumemeas::Scan& Message::scan() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Message.scan)
  return has_scan()
      ? *data_.scan_
      : ::lrobot::lidarvolumemeas::Scan::default_instance();
}
inline ::lrobot::lidarvolumemeas::Scan* Message::mutable_scan() {
  if (!has_scan()) {
    clear_data();
    set_has_scan();
    data_.scan_ = new ::lrobot::lidarvolumemeas::Scan;
  }
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Message.scan)
  return data_.scan_;
}
inline ::lrobot::lidarvolumemeas::Scan* Message::release_scan() {
  // @@protoc_insertion_point(field_release:lrobot.lidarvolumemeas.Message.scan)
  if (has_scan()) {
    clear_has_data();
    ::lrobot::lidarvolumemeas::Scan* temp = data_.scan_;
    data_.scan_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_scan(::lrobot::lidarvolumemeas::Scan* scan) {
  clear_data();
  if (scan) {
    set_has_scan();
    data_.scan_ = scan;
  }
  // @@protoc_insertion_point(field_set_allocated:lrobot.lidarvolumemeas.Message.scan)
}

// optional .lrobot.lidarvolumemeas.MeasResult result = 3;
inline bool Message::has_result() const {
  return data_case() == kResult;
}
inline void Message::set_has_result() {
  _oneof_case_[0] = kResult;
}
inline void Message::clear_result() {
  if (has_result()) {
    delete data_.result_;
    clear_has_data();
  }
}
inline  const ::lrobot::lidarvolumemeas::MeasResult& Message::result() const {
  // @@protoc_insertion_point(field_get:lrobot.lidarvolumemeas.Message.result)
  return has_result()
      ? *data_.result_
      : ::lrobot::lidarvolumemeas::MeasResult::default_instance();
}
inline ::lrobot::lidarvolumemeas::MeasResult* Message::mutable_result() {
  if (!has_result()) {
    clear_data();
    set_has_result();
    data_.result_ = new ::lrobot::lidarvolumemeas::MeasResult;
  }
  // @@protoc_insertion_point(field_mutable:lrobot.lidarvolumemeas.Message.result)
  return data_.result_;
}
inline ::lrobot::lidarvolumemeas::MeasResult* Message::release_result() {
  // @@protoc_insertion_point(field_release:lrobot.lidarvolumemeas.Message.result)
  if (has_result()) {
    clear_has_data();
    ::lrobot::lidarvolumemeas::MeasResult* temp = data_.result_;
    data_.result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_result(::lrobot::lidarvolumemeas::MeasResult* result) {
  clear_data();
  if (result) {
    set_has_result();
    data_.result_ = result;
  }
  // @@protoc_insertion_point(field_set_allocated:lrobot.lidarvolumemeas.Message.result)
}

inline bool Message::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void Message::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline Message::DataCase Message::data_case() const {
  return Message::DataCase(_oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace lidarvolumemeas
}  // namespace lrobot

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::lrobot::lidarvolumemeas::State> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::lrobot::lidarvolumemeas::State>() {
  return ::lrobot::lidarvolumemeas::State_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_proto_2fmessage_2eproto__INCLUDED
